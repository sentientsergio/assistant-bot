/**
 * Telegram Channel â€” v2
 *
 * Connects the gateway to Telegram via grammY.
 * Only responds to messages from the configured owner user ID.
 *
 * Uses the unified conversation state â€” one messages array across all channels.
 * No auto-fetching of memories, facts, or cross-channel summaries.
 * Claire uses tools (search_memory, update_status) when she needs them.
 */

import { Bot, Context } from 'grammy';
import { chat, ChatResult } from '../claude.js';
import {
  appendUserMessage,
  rollbackLastUserMessage,
  enqueueTurn,
  persistState,
} from '../conversation-state.js';
import {
  storeExchange,
  isInitialized as isMemoryInitialized,
} from '../memory/index.js';
import { addMessage } from '../conversation.js';
import * as fs from 'fs/promises';
import * as path from 'path';

let bot: Bot | null = null;
let ownerChatId: number | null = null;

interface TelegramConfig {
  token: string;
  ownerId: number;
  workspacePath: string;
}

async function getShowThinking(workspacePath: string): Promise<boolean> {
  try {
    const statusPath = path.join(workspacePath, 'status.json');
    const content = await fs.readFile(statusPath, 'utf-8');
    const status = JSON.parse(content);
    return status.preferences?.show_thinking ?? false;
  } catch {
    return false;
  }
}

async function setShowThinking(workspacePath: string, value: boolean): Promise<void> {
  const statusPath = path.join(workspacePath, 'status.json');
  const content = await fs.readFile(statusPath, 'utf-8');
  const status = JSON.parse(content);

  if (!status.preferences) {
    status.preferences = {};
  }
  status.preferences.show_thinking = value;

  await fs.writeFile(statusPath, JSON.stringify(status, null, 2));
  console.log(`[telegram] Set show_thinking to ${value}`);
}

function parseThinkingCommand(message: string): 'show' | 'hide' | null {
  const lower = message.toLowerCase().trim();
  if (lower.match(/\b(show|enable|turn on)\b.*thinking/i)) return 'show';
  if (lower.match(/\b(hide|disable|turn off)\b.*thinking/i)) return 'hide';
  return null;
}

export async function startTelegram(config: TelegramConfig): Promise<Bot> {
  const { token, ownerId, workspacePath } = config;

  bot = new Bot(token);
  ownerChatId = ownerId;

  bot.use(async (ctx, next) => {
    if (ctx.from?.id !== ownerId) {
      console.log(`[telegram] Ignoring message from non-owner: ${ctx.from?.id}`);
      return;
    }
    await next();
  });

  bot.on('message:text', async (ctx) => {
    const userMessage = ctx.message.text;
    console.log(`[telegram] Received: "${userMessage.substring(0, 50)}..."`);

    const thinkingCommand = parseThinkingCommand(userMessage);
    if (thinkingCommand) {
      const newValue = thinkingCommand === 'show';
      await setShowThinking(workspacePath, newValue);
      await ctx.reply(
        newValue
          ? "ðŸ§  Thinking mode enabled. I'll show you my reasoning process."
          : "ðŸ§  Thinking mode disabled. I'll just show you my responses."
      );
      return;
    }

    await ctx.replyWithChatAction('typing');

    try {
      const result = await enqueueTurn(async () => {
        appendUserMessage(userMessage);
        try {
          return await chat(workspacePath);
        } catch (err) {
          rollbackLastUserMessage();
          throw err;
        }
      });

      const showThinking = await getShowThinking(workspacePath);
      let fullResponse: string;
      if (showThinking && result.thinking) {
        fullResponse = `<thinking>\n${result.thinking}\n</thinking>\n\n${result.text}`;
      } else {
        fullResponse = result.text;
      }

      // Log to messages.json for heartbeat context and cross-channel reads
      await addMessage(workspacePath, 'telegram', 'user', userMessage);
      await addMessage(workspacePath, 'telegram', 'assistant', result.text);

      // Store in vector memory for deep recall
      if (isMemoryInitialized()) {
        storeExchange(userMessage, result.text, 'telegram').catch(err => {
          console.error('[telegram] Failed to store exchange in memory:', err);
        });
      }

      await sendLongMessage(ctx, fullResponse);
      console.log(`[telegram] Sent response (${fullResponse.length} chars)`);

    } catch (err) {
      console.error('[telegram] Error:', err);
      const isOverloaded = err instanceof Error && err.message.includes('529');
      const errMsg = isOverloaded
        ? "I'm temporarily overwhelmed (Anthropic is overloaded). Give it a moment and try again."
        : 'Sorry, I encountered an error. Please try again.';
      await ctx.reply(errMsg);
    }
  });

  bot.command('start', async (ctx) => {
    await ctx.reply(
      "Hey! I'm your assistant. Just send me a message and I'll respond.\n\n" +
      "I have access to my workspace files, so I know who I am and who you are."
    );
  });

  bot.command('status', async (ctx) => {
    const uptime = process.uptime();
    const hours = Math.floor(uptime / 3600);
    const minutes = Math.floor((uptime % 3600) / 60);

    await ctx.reply(
      `ðŸŸ¢ Online\n` +
      `â± Uptime: ${hours}h ${minutes}m\n` +
      `ðŸ“ Workspace: connected`
    );
  });

  bot.on('message:document', async (ctx) => {
    const doc = ctx.message.document;
    const caption = ctx.message.caption || '';

    console.log(`[telegram] Received document: ${doc.file_name} (${doc.mime_type})`);
    await ctx.replyWithChatAction('typing');

    try {
      const userMessage = caption
        ? `[Attached document: ${doc.file_name} (${doc.mime_type})]\n\n${caption}`
        : `[Attached document: ${doc.file_name} (${doc.mime_type})]\n\n(User shared this document without additional text. Acknowledge receipt and ask if they want to discuss it, or note that you cannot yet read document contents directly.)`;

      const result = await enqueueTurn(async () => {
        appendUserMessage(userMessage);
        return await chat(workspacePath);
      });

      await addMessage(workspacePath, 'telegram', 'user', userMessage);
      await addMessage(workspacePath, 'telegram', 'assistant', result.text);

      const showThinking = await getShowThinking(workspacePath);
      const fullResponse = showThinking && result.thinking
        ? `<thinking>\n${result.thinking}\n</thinking>\n\n${result.text}`
        : result.text;

      await sendLongMessage(ctx, fullResponse);
      console.log(`[telegram] Responded to document (${fullResponse.length} chars)`);

    } catch (err) {
      console.error('[telegram] Error handling document:', err);
      await ctx.reply('Sorry, I encountered an error processing that document. Please try again.');
    }
  });

  bot.on('message:photo', async (ctx) => {
    const caption = ctx.message.caption || '';
    console.log(`[telegram] Received photo`);
    await ctx.replyWithChatAction('typing');

    try {
      const userMessage = caption
        ? `[Attached photo]\n\n${caption}`
        : `[Attached photo]\n\n(User shared a photo without additional text. Acknowledge receipt. Note that you cannot yet see image contents directly.)`;

      const result = await enqueueTurn(async () => {
        appendUserMessage(userMessage);
        return await chat(workspacePath);
      });

      await addMessage(workspacePath, 'telegram', 'user', userMessage);
      await addMessage(workspacePath, 'telegram', 'assistant', result.text);

      const showThinking = await getShowThinking(workspacePath);
      const fullResponse = showThinking && result.thinking
        ? `<thinking>\n${result.thinking}\n</thinking>\n\n${result.text}`
        : result.text;

      await sendLongMessage(ctx, fullResponse);
      console.log(`[telegram] Responded to photo (${fullResponse.length} chars)`);

    } catch (err) {
      console.error('[telegram] Error handling photo:', err);
      await ctx.reply('Sorry, I encountered an error processing that photo. Please try again.');
    }
  });

  console.log('[telegram] Starting bot...');

  bot.start({
    onStart: (botInfo) => {
      console.log(`[telegram] Bot started: @${botInfo.username}`);
    },
  });

  return bot;
}

async function sendLongMessage(ctx: Context, text: string): Promise<void> {
  const MAX_LENGTH = 4000;

  if (text.length <= MAX_LENGTH) {
    await ctx.reply(text);
    return;
  }

  const chunks: string[] = [];
  let remaining = text;

  while (remaining.length > 0) {
    if (remaining.length <= MAX_LENGTH) {
      chunks.push(remaining);
      break;
    }

    let splitAt = remaining.lastIndexOf('\n\n', MAX_LENGTH);
    if (splitAt === -1 || splitAt < MAX_LENGTH / 2) {
      splitAt = remaining.lastIndexOf('\n', MAX_LENGTH);
    }
    if (splitAt === -1 || splitAt < MAX_LENGTH / 2) {
      splitAt = remaining.lastIndexOf(' ', MAX_LENGTH);
    }
    if (splitAt === -1) {
      splitAt = MAX_LENGTH;
    }

    chunks.push(remaining.substring(0, splitAt));
    remaining = remaining.substring(splitAt).trimStart();
  }

  for (const chunk of chunks) {
    await ctx.reply(chunk);
  }
}

export async function sendToOwner(message: string): Promise<boolean> {
  if (!bot || !ownerChatId) {
    console.error('[telegram] Bot not initialized or owner ID not set');
    return false;
  }

  try {
    await bot.api.sendMessage(ownerChatId, message);
    console.log(`[telegram] Sent proactive message to owner`);
    return true;
  } catch (err) {
    console.error('[telegram] Failed to send to owner:', err);
    return false;
  }
}

export function stopTelegram(): void {
  if (bot) {
    bot.stop();
    bot = null;
    console.log('[telegram] Bot stopped');
  }
}

export function isTelegramRunning(): boolean {
  return bot !== null;
}
